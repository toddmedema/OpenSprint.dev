import { describe, it, expect, vi, beforeEach } from "vitest";
import {
  MergeCoordinatorService,
  type MergeCoordinatorHost,
  type MergeSlot,
} from "../services/merge-coordinator.service.js";
import type { StoredTask } from "../services/task-store.service.js";

vi.mock("../services/task-store.service.js", () => ({
  taskStore: {},
}));

vi.mock("../services/branch-manager.js", () => {
  class RebaseConflictError extends Error {
    constructor(public readonly conflictedFiles: string[]) {
      super(`Rebase conflict in ${conflictedFiles.length} file(s)`);
      this.name = "RebaseConflictError";
    }
  }
  return {
    RebaseConflictError,
    BranchManager: vi.fn().mockImplementation(() => ({
      waitForGitReady: vi.fn(),
      commitWip: vi.fn(),
      removeTaskWorktree: vi.fn(),
      deleteBranch: vi.fn(),
      getChangedFiles: vi.fn(),
      pushMain: vi.fn(),
      pushMainToOrigin: vi.fn(),
      isMergeInProgress: vi.fn(),
      mergeAbort: vi.fn(),
      mergeContinue: vi.fn(),
      rebaseAbort: vi.fn(),
      rebaseContinue: vi.fn(),
      getDiff: vi.fn(),
    })),
  };
});

const mockRemoveTaskWorktree = vi.fn();
const mockDeleteBranch = vi.fn();
const mockGetSettings = vi.fn();
const mockGitQueueDrain = vi.fn();
const mockGitQueueEnqueueAndWait = vi.fn();

vi.mock("../services/git-commit-queue.service.js", () => ({
  MergeJobError: class MergeJobError extends Error {
    constructor(
      message: string,
      public readonly stage: "rebase_before_merge" | "merge_to_main",
      public readonly conflictedFiles: string[],
      public readonly resolvedBy: "requeued" | "blocked" = "requeued"
    ) {
      super(message);
      this.name = "MergeJobError";
    }
  },
  gitCommitQueue: {
    drain: () => mockGitQueueDrain(),
    enqueueAndWait: (opts: unknown) => mockGitQueueEnqueueAndWait(opts),
  },
}));

vi.mock("../services/agent-identity.service.js", () => ({
  agentIdentityService: {
    recordAttempt: vi.fn().mockResolvedValue(undefined),
  },
}));

vi.mock("../services/event-log.service.js", () => ({
  eventLogService: {
    append: vi.fn().mockResolvedValue(undefined),
  },
}));

vi.mock("../websocket/index.js", () => ({
  broadcastToProject: vi.fn(),
}));

vi.mock("../services/deploy-trigger.service.js", () => ({
  triggerDeployForEvent: vi.fn().mockResolvedValue(undefined),
}));

vi.mock("../services/final-review.service.js", () => ({
  finalReviewService: {
    runFinalReview: vi.fn(),
    createTasksFromReview: vi.fn(),
  },
}));

describe("MergeCoordinatorService", () => {
  let coordinator: MergeCoordinatorService;
  let mockHost: MergeCoordinatorHost;
  const projectId = "proj-1";
  const repoPath = "/tmp/repo";
  const taskId = "os-abc1";
  const branchName = `opensprint/${taskId}`;

  const makeTask = (): StoredTask => ({
    id: taskId,
    title: "Test task",
    status: "open",
    priority: 2,
    issue_type: "task",
    type: "task",
    labels: [],
    assignee: null,
    description: "",
    created: new Date().toISOString(),
    updated: new Date().toISOString(),
  });

  const makeSlot = (worktreePath: string | null = "/tmp/worktree"): MergeSlot => ({
    taskId,
    attempt: 1,
    worktreePath,
    branchName,
    phaseResult: {
      codingDiff: "",
      codingSummary: "Done",
      testResults: null,
      testOutput: "",
    },
    agent: { outputLog: [], startedAt: new Date().toISOString() },
  });

  beforeEach(() => {
    vi.clearAllMocks();
    mockGitQueueDrain.mockResolvedValue(undefined);
    mockGitQueueEnqueueAndWait.mockResolvedValue(undefined);
    mockGetSettings.mockResolvedValue({
      simpleComplexityAgent: { type: "cursor", model: null },
      complexComplexityAgent: { type: "cursor", model: null },
      deployment: { mode: "custom" },
      gitWorkingMode: "worktree",
    });

    mockHost = {
      getState: vi.fn().mockReturnValue({
        slots: new Map([[taskId, makeSlot()]]),
        status: { totalDone: 0, queueDepth: 0 },
        globalTimers: {},
      }),
      taskStore: {
        close: vi.fn().mockResolvedValue(undefined),
        update: vi.fn().mockResolvedValue(undefined),
        comment: vi.fn().mockResolvedValue(undefined),
        sync: vi.fn().mockResolvedValue(undefined),
        syncForPush: vi.fn().mockResolvedValue(undefined),
        listAll: vi.fn().mockResolvedValue([]),
        show: vi.fn().mockResolvedValue(makeTask()),
        setCumulativeAttempts: vi.fn().mockResolvedValue(undefined),
        getCumulativeAttemptsFromIssue: vi.fn().mockReturnValue(0),
        setConflictFiles: vi.fn().mockResolvedValue(undefined),
        setMergeStage: vi.fn().mockResolvedValue(undefined),
      },
      branchManager: {
        waitForGitReady: vi.fn().mockResolvedValue(undefined),
        commitWip: vi.fn().mockResolvedValue(undefined),
        removeTaskWorktree: mockRemoveTaskWorktree.mockResolvedValue(undefined),
        deleteBranch: mockDeleteBranch.mockResolvedValue(undefined),
        getChangedFiles: vi.fn().mockResolvedValue([]),
        pushMain: vi.fn().mockResolvedValue(undefined),
        pushMainToOrigin: vi.fn().mockResolvedValue(undefined),
        isMergeInProgress: vi.fn().mockResolvedValue(false),
        mergeAbort: vi.fn().mockResolvedValue(undefined),
        mergeContinue: vi.fn().mockResolvedValue(undefined),
        rebaseAbort: vi.fn().mockResolvedValue(undefined),
        rebaseContinue: vi.fn().mockResolvedValue(undefined),
      },
      runMergerAgentAndWait: vi.fn().mockResolvedValue(false),
      sessionManager: {
        createSession: vi.fn().mockResolvedValue({ id: "sess-1" }),
        archiveSession: vi.fn().mockResolvedValue(undefined),
      },
      fileScopeAnalyzer: {
        recordActual: vi.fn().mockResolvedValue(undefined),
      },
      feedbackService: {
        checkAutoResolveOnTaskDone: vi.fn().mockResolvedValue(undefined),
      },
      projectService: {
        getSettings: mockGetSettings,
      },
      transition: vi.fn(),
      persistCounters: vi.fn().mockResolvedValue(undefined),
      nudge: vi.fn(),
    };

    coordinator = new MergeCoordinatorService(mockHost);
  });

  it("calls removeTaskWorktree when gitWorkingMode is worktree", async () => {
    mockGetSettings.mockResolvedValue({
      simpleComplexityAgent: { type: "cursor", model: null },
      complexComplexityAgent: { type: "cursor", model: null },
      deployment: {},
      gitWorkingMode: "worktree",
    });

    await coordinator.performMergeAndDone(projectId, repoPath, makeTask(), branchName);

    await vi.waitFor(() => {
      expect(mockRemoveTaskWorktree).toHaveBeenCalledWith(repoPath, taskId, "/tmp/worktree");
      expect(mockDeleteBranch).toHaveBeenCalledWith(repoPath, branchName);
    });
  });

  it("skips removeTaskWorktree when gitWorkingMode is branches", async () => {
    mockGetSettings.mockResolvedValue({
      simpleComplexityAgent: { type: "cursor", model: null },
      complexComplexityAgent: { type: "cursor", model: null },
      deployment: {},
      gitWorkingMode: "branches",
    });

    await coordinator.performMergeAndDone(projectId, repoPath, makeTask(), branchName);

    await vi.waitFor(() => {
      expect(mockRemoveTaskWorktree).not.toHaveBeenCalled();
      expect(mockDeleteBranch).toHaveBeenCalledWith(repoPath, branchName);
    });
  });

  it("skips removeTaskWorktree when gitWorkingMode is missing (defaults to worktree behavior)", async () => {
    mockGetSettings.mockResolvedValue({
      simpleComplexityAgent: { type: "cursor", model: null },
      complexComplexityAgent: { type: "cursor", model: null },
      deployment: {},
      // gitWorkingMode omitted
    });

    await coordinator.performMergeAndDone(projectId, repoPath, makeTask(), branchName);

    await vi.waitFor(() => {
      expect(mockRemoveTaskWorktree).toHaveBeenCalledWith(repoPath, taskId, "/tmp/worktree");
      expect(mockDeleteBranch).toHaveBeenCalledWith(repoPath, branchName);
    });
  });

  it("always calls deleteBranch regardless of gitWorkingMode", async () => {
    for (const mode of ["worktree", "branches"] as const) {
      vi.clearAllMocks();
      mockRemoveTaskWorktree.mockResolvedValue(undefined);
      mockDeleteBranch.mockResolvedValue(undefined);

      mockGetSettings.mockResolvedValue({
        simpleComplexityAgent: { type: "cursor", model: null },
        complexComplexityAgent: { type: "cursor", model: null },
        deployment: {},
        gitWorkingMode: mode,
      });

      await coordinator.performMergeAndDone(projectId, repoPath, makeTask(), branchName);

      await vi.waitFor(() => {
        expect(mockDeleteBranch).toHaveBeenCalledWith(repoPath, branchName);
      });
    }
  });

  it("enqueues merge job with worktreePath so rebase happens inside the serialized queue", async () => {
    const slot = makeSlot("/tmp/worktree");
    mockHost.getState = vi.fn().mockReturnValue({
      slots: new Map([[taskId, slot]]),
      status: { totalDone: 0, queueDepth: 0 },
      globalTimers: {},
    });

    await coordinator.performMergeAndDone(projectId, repoPath, makeTask(), branchName);

    expect(mockGitQueueEnqueueAndWait).toHaveBeenCalledWith(
      expect.objectContaining({
        type: "worktree_merge",
        repoPath,
        worktreePath: "/tmp/worktree",
        branchName,
        taskId,
      })
    );
  });

  it("archives session when merge fails so task detail sidebar can show output", async () => {
    const slotWithOutput = makeSlot();
    slotWithOutput.agent.outputLog = ["Agent output line 1\n", "Agent output line 2\n"];
    mockHost.getState = vi.fn().mockReturnValue({
      slots: new Map([[taskId, slotWithOutput]]),
      status: { totalDone: 0, queueDepth: 0 },
      globalTimers: {},
    });
    mockGitQueueEnqueueAndWait.mockRejectedValue(new Error("merge conflict"));

    await coordinator.performMergeAndDone(projectId, repoPath, makeTask(), branchName);

    expect(mockHost.sessionManager.createSession).toHaveBeenCalledWith(
      repoPath,
      expect.objectContaining({
        taskId,
        status: "failed",
        outputLog: "Agent output line 1\nAgent output line 2\n",
        failureReason: "merge conflict",
      })
    );
    expect(mockHost.sessionManager.archiveSession).toHaveBeenCalledWith(
      repoPath,
      taskId,
      1,
      expect.anything(),
      "/tmp/worktree"
    );
  });

  it("requeues task when merge job fails", async () => {
    mockGitQueueEnqueueAndWait.mockRejectedValue(new Error("merge conflict"));

    await coordinator.performMergeAndDone(projectId, repoPath, makeTask(), branchName);

    expect(mockHost.taskStore.update).toHaveBeenCalledWith(
      projectId,
      taskId,
      expect.objectContaining({ status: "open" })
    );
  });

  it("runs final review when last task of epic completes and closes epic on pass", async () => {
    const { finalReviewService } = await import("../services/final-review.service.js");
    vi.mocked(finalReviewService.runFinalReview).mockResolvedValue({
      status: "pass",
      assessment: "Implementation meets plan scope.",
      proposedTasks: [],
    });
    mockHost.taskStore.listAll.mockResolvedValue([
      { id: "os-abc", title: "Epic", status: "open", issue_type: "epic" } as never,
      { id: "os-abc.1", title: "Task 1", status: "closed", issue_type: "task" } as never,
    ]);

    await coordinator.postCompletionAsync(projectId, repoPath, "os-abc.1");

    await vi.waitFor(() => {
      expect(finalReviewService.runFinalReview).toHaveBeenCalledWith(
        projectId,
        "os-abc",
        repoPath
      );
    });
    expect(mockHost.taskStore.close).toHaveBeenCalledWith(
      projectId,
      "os-abc",
      "All tasks done; final review passed"
    );
  });

  it("creates tasks and nudges when final review finds issues", async () => {
    const { finalReviewService } = await import("../services/final-review.service.js");
    vi.mocked(finalReviewService.runFinalReview).mockResolvedValue({
      status: "issues",
      assessment: "Missing error handling.",
      proposedTasks: [
        { title: "Add error handling", description: "Handle edge cases", priority: 1 },
      ],
    });
    vi.mocked(finalReviewService.createTasksFromReview).mockResolvedValue(["os-abc.2"]);
    mockHost.taskStore.listAll.mockResolvedValue([
      { id: "os-abc", title: "Epic", status: "open", issue_type: "epic" } as never,
      { id: "os-abc.1", title: "Task 1", status: "closed", issue_type: "task" } as never,
    ]);
    const nudge = vi.fn();
    mockHost.nudge = nudge;

    await coordinator.postCompletionAsync(projectId, repoPath, "os-abc.1");

    await vi.waitFor(() => {
      expect(finalReviewService.runFinalReview).toHaveBeenCalledWith(
        projectId,
        "os-abc",
        repoPath
      );
    });
    expect(finalReviewService.createTasksFromReview).toHaveBeenCalledWith(
      projectId,
      "os-abc",
      [{ title: "Add error handling", description: "Handle edge cases", priority: 1 }]
    );
    expect(mockHost.taskStore.close).not.toHaveBeenCalledWith(
      projectId,
      "os-abc",
      expect.any(String)
    );
    expect(nudge).toHaveBeenCalled();
  });
});
