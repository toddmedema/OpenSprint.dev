/**
 * TaskPhaseCoordinator â€” safe join point for parallel test + review results.
 *
 * When coding succeeds, tests and review run concurrently. This coordinator
 * collects both outcomes and calls a single resolution handler when both
 * are complete, eliminating the race where two async paths mutate slot state.
 */

import type { TestResults, ReviewAgentResult } from "@opensprint/shared";
import { createLogger } from "../utils/logger.js";

const log = createLogger("phase-coordinator");

export interface TestOutcome {
  status: "passed" | "failed" | "error";
  results?: TestResults;
  rawOutput?: string;
  errorMessage?: string;
}

export interface ReviewOutcome {
  status: "approved" | "rejected" | "no_result" | "error";
  result?: ReviewAgentResult | null;
  exitCode: number | null;
}

export type PhaseResolution = (test: TestOutcome, review: ReviewOutcome) => Promise<void>;

const DEFAULT_REVIEW_KEY = "__general_review__";

export interface TaskPhaseCoordinatorOptions {
  reviewAngles?: string[];
}

export class TaskPhaseCoordinator {
  private testOutcome: TestOutcome | null = null;
  private readonly expectedReviewKeys: Set<string>;
  private readonly reviewOutcomes = new Map<string, ReviewOutcome>();
  private resolved = false;

  constructor(
    private readonly taskId: string,
    private readonly resolve: PhaseResolution,
    options?: TaskPhaseCoordinatorOptions
  ) {
    const angles = options?.reviewAngles?.filter(Boolean) ?? [];
    this.expectedReviewKeys = new Set(angles.length > 0 ? angles : [DEFAULT_REVIEW_KEY]);
  }

  setTestOutcome(outcome: TestOutcome): void {
    if (this.resolved) return;
    this.testOutcome = outcome;
    log.info("Test outcome received", { taskId: this.taskId, status: outcome.status });
    this.tryResolve();
  }

  setReviewOutcome(outcome: ReviewOutcome, angle?: string): void {
    if (this.resolved) return;
    const key = this.resolveReviewKey(angle);
    this.reviewOutcomes.set(key, outcome);
    log.info("Review outcome received", {
      taskId: this.taskId,
      status: outcome.status,
      reviewKey: key,
      received: this.reviewOutcomes.size,
      expected: this.expectedReviewKeys.size,
    });
    this.tryResolve();
  }

  private tryResolve(): void {
    if (this.resolved || !this.testOutcome) return;
    const reviewOutcome = this.getAggregatedReviewOutcome();
    if (!reviewOutcome) return;

    this.resolved = true;
    log.info("Both outcomes ready, resolving", {
      taskId: this.taskId,
      test: this.testOutcome.status,
      review: reviewOutcome.status,
      reviewCount: this.reviewOutcomes.size,
    });
    this.resolve(this.testOutcome, reviewOutcome).catch((err) => {
      log.error("Phase resolution failed", { taskId: this.taskId, err });
    });
  }

  private resolveReviewKey(angle?: string): string {
    if (angle && this.expectedReviewKeys.has(angle)) return angle;
    if (!angle && this.expectedReviewKeys.size === 1) {
      return [...this.expectedReviewKeys][0]!;
    }
    if (angle) return angle;
    return DEFAULT_REVIEW_KEY;
  }

  private getAggregatedReviewOutcome(): ReviewOutcome | null {
    for (const key of this.expectedReviewKeys) {
      if (!this.reviewOutcomes.has(key)) return null;
    }

    const outcomes = [...this.expectedReviewKeys].map((key) => this.reviewOutcomes.get(key)!);
    const firstNoResult = outcomes.find((o) => o.status === "no_result" || o.status === "error");
    if (firstNoResult) {
      return { status: "no_result", result: null, exitCode: firstNoResult.exitCode };
    }

    const rejected = outcomes.filter((o) => o.status === "rejected");
    if (rejected.length > 0) {
      const mergedIssues = [
        ...new Set(
          rejected
            .flatMap((o) => o.result?.issues ?? [])
            .map((issue) => issue.trim())
            .filter(Boolean)
        ),
      ];
      const mergedSummary = rejected
        .map((o) => o.result?.summary?.trim() ?? "")
        .filter(Boolean)
        .join(" | ");
      const mergedNotes = rejected
        .map((o) => o.result?.notes?.trim() ?? "")
        .filter(Boolean)
        .join("\n\n");

      return {
        status: "rejected",
        exitCode: rejected[0]?.exitCode ?? null,
        result: {
          status: "rejected",
          summary: mergedSummary || "Review rejected",
          ...(mergedIssues.length > 0 && { issues: mergedIssues }),
          notes: mergedNotes,
        },
      };
    }

    return {
      status: "approved",
      result: outcomes[0]?.result ?? null,
      exitCode: outcomes[0]?.exitCode ?? 0,
    };
  }
}
