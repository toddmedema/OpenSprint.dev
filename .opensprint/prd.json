{
  "version": 2,
  "sections": {
    "executive_summary": {
      "content": "OpenSprint is a web application that guides users through the complete software development lifecycle using AI agents. It provides a structured, five-phase workflow — **SPEED**: Spec, Plan, Execute, Evaluate, and Deploy — that transforms high-level product ideas into working software with minimal manual intervention.\n\nThe platform pairs a browser-based interface with a background agent CLI, enabling AI to autonomously execute development tasks while keeping the user in control of strategy and direction. The core philosophy is that humans should focus on _what_ to build and _why_, while AI handles _how_ to build it.\n\nOpenSprint supports multiple agent backends (Claude, Cursor, and custom CLI agents), comprehensive automated testing including end-to-end and integration tests, configurable human-in-the-loop thresholds, and full offline operation for users with local agent setups.\n\n---",
      "version": 1,
      "updatedAt": "2026-02-17T19:19:10.658Z"
    },
    "problem_statement": {
      "content": "Building software with AI today is fragmented and unstructured. Developers use AI coding assistants for individual tasks, but there is no cohesive system that manages the full journey from idea to deployed product. This leads to several persistent problems:\n\n- **Lack of architectural coherence:** AI-generated code often lacks a unified vision because each prompt is handled in isolation, without awareness of the broader system design.\n- **No dependency tracking:** When building features in parallel, there is no mechanism to ensure that work on one feature accounts for dependencies on another.\n- **Manual orchestration overhead:** Users spend significant time managing prompts, context windows, and task sequencing rather than focusing on product decisions.\n- **No feedback loop:** There is no structured way to validate completed work and feed findings back into the development process.\n\nOpenSprint solves these problems by providing an end-to-end platform that maintains context across the entire lifecycle and automates the orchestration of AI development agents.\n\n---",
      "version": 1,
      "updatedAt": "2026-02-17T19:19:10.658Z"
    },
    "goals_and_metrics": {
      "content": "### 3.1 Primary Goals\n\n1. Reduce the time from idea to working prototype by 10x compared to traditional AI-assisted development workflows.\n2. Enable non-engineers to ship production-quality software by handling technical complexity behind the scenes.\n3. Maintain architectural coherence across an entire project by flowing design decisions through every phase.\n4. Create a self-improving development flywheel where validation feedback automatically triggers corrective action.\n\n### 3.2 Success Metrics\n\n| Metric                                | Target                                     | Measurement Method              |\n| ------------------------------------- | ------------------------------------------ | ------------------------------- |\n| Time from idea to working prototype   | < 1 day for standard web apps              | End-to-end session timing       |\n| User intervention rate during Execute | < 10% of tasks require manual input        | Task completion telemetry       |\n| Spec-to-code fidelity                 | > 90% alignment with PRD                   | Automated PRD compliance checks |\n| Feedback loop closure time            | < 30 min from bug report to fix deployed   | Evaluate-to-Execute cycle tracking  |\n| First-time user task completion       | > 80% complete a full Spec-Execute cycle   | Onboarding funnel analytics     |\n| Test coverage                         | > 80% code coverage with passing E2E tests | Automated coverage reporting    |\n\n---",
      "version": 1,
      "updatedAt": "2026-02-17T19:19:10.658Z"
    },
    "user_personas": {
      "content": "### 4.1 The Product-Minded Founder\n\nA non-technical founder with a clear product vision who wants to build an MVP without hiring a development team. They understand what they want to build but need AI to handle the engineering. They value speed, clear communication about what is being built, and the ability to provide feedback without writing code.\n\n### 4.2 The Solo Developer\n\nAn experienced developer who wants to multiply their output. They can code but want to delegate routine implementation to AI while focusing on architecture and product decisions. They value transparency into what the AI is doing, the ability to intervene when needed, and high-quality code output.\n\n### 4.3 The Agency / Consultancy\n\nA small team that builds software for clients. They need to move quickly from client requirements to working software, maintain multiple projects simultaneously, and provide clients with visibility into progress. They value the structured workflow for client communication and the ability to run multiple projects in parallel.\n\n---",
      "version": 1,
      "updatedAt": "2026-02-17T19:19:10.658Z"
    },
    "technical_architecture": {
      "content": "### 5.1 Architecture Overview\n\nOpenSprint consists of three primary layers: a web-based frontend, a backend API server, and a background agent CLI that executes development work. The frontend communicates with the backend via WebSockets for real-time updates and REST APIs for CRUD operations. The backend orchestrates agent CLI instances, manages project state, and maintains the living PRD.\n\nOpenSprint is designed to run entirely offline. The web frontend and backend API server run locally on the user's machine. When using a local agent CLI (such as a locally-hosted LLM), the entire development loop — from Spec through Deploy — operates without any internet connectivity. Beads is git-based and inherently offline-compatible with no special synchronization logic required.\n\n### 5.2 Technology Stack\n\n**Backend:** Node.js with TypeScript. This provides a shared language and type system with the React frontend, mature WebSocket support, and robust subprocess management for agent CLIs via `child_process`. Beads is invoked via its CLI (`bd`) using `child_process.exec()` with `--json` flags for structured output.\n\n**Frontend:** React with TypeScript.\n\n### 5.3 Core Components\n\n| Component           | Technology                            | Responsibility                                                                                                                                                                                                                                                                                                                                                                                                                                   |\n| ------------------- | ------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| Web Frontend        | React + TypeScript                    | User interface for all five phases; real-time agent monitoring; project management                                                                                                                                                                                                                                                                                                                                                               |\n| Backend API         | Node.js + TypeScript                  | Project state management, WebSocket relay, PRD versioning, agent orchestration                                                                                                                                                                                                                                                                                                                                                                   |\n| Agent CLI           | Pluggable (Claude, Cursor, Custom)    | Executes development tasks: code generation, testing, debugging                                                                                                                                                                                                                                                                                                                                                                                  |\n| Orchestration Layer | Node.js (custom, deterministic)       | Always-on agent lifecycle management (spawn, monitor, timeout), context assembly, Summarizer invocation, retry logic, code review triggering. Owns all critical git and beads operations (worktree, commit, merge, issue creation, state transitions). Serialized git commit queue for main-branch operations (Section 5.9). Event-driven dispatch with 5-minute watchdog. Crash recovery via persistent state. See Sections 5.5, 5.7, 5.8, 5.9. |\n| Beads               | Git-based issue tracker (CLI: `bd`)   | Issue storage, dependency tracking (blocks/related/parent-child/discovered-from), ready-work detection and prioritization via `bd ready`, agent assignment via `assignee` field, hierarchical epic/task IDs, provenance via audit trail, JSONL-backed distributed state                                                                                                                                                                          |\n| Version Control     | Git                                   | Code repository management, branch-per-task strategy                                                                                                                                                                                                                                                                                                                                                                                             |\n| Test Runner         | Configurable (Jest, Playwright, etc.) | Automated test execution and coverage reporting                                                                                                                                                                                                                                                                                                                                                                                                  |\n| Deployment          | Expo.dev / Custom pipeline            | Automated deployment for supported platforms                                                                                                                                                                                                                                                                                                                                                                                                     |\n\n### 5.4 Beads Integration Details\n\n[Beads](https://github.com/steveyegge/beads) provides the persistence, dependency, and scheduling layer. OpenSprint's orchestration layer is thin and delegates heavily to beads.\n\n**What beads provides natively (and OpenSprint uses directly):**\n\n- Issue CRUD with priorities (0-4), statuses (open/in_progress/closed), assignees, labels, and types (bug/feature/task/epic/chore)\n- Four dependency types: blocks, related, parent-child, discovered-from\n- `bd ready --json` — finds issues with no open blockers, sorted by priority. This is OpenSprint's execution queue — the orchestrator simply calls `bd ready` and picks the first result\n- `assignee` field — the orchestrator uses `bd update <id> --assignee agent-<id>` to track which agent is working on a task\n- Hierarchical child IDs (e.g., `bd-a3f8.1`, `bd-a3f8.2`) for epic → task breakdown\n- JSON output on all commands for programmatic integration\n- Hash-based collision-resistant IDs\n- Git-backed JSONL storage (auto-commit disabled — see Section 5.9; orchestrator manages git persistence explicitly)\n- Daemon with real-time event capabilities (daemon runs for SQLite performance; git sync handled by orchestrator)\n- Full audit trail of every change\n\n**Planning state via gating task:** Each epic gets a gating task (e.g., `bd-a3f8.0 \"Plan approval gate\"`) that `blocks` all child implementation tasks. While the gate is open, `bd ready` excludes all children. When the user clicks \"Execute!\", the orchestrator closes the gate, unblocking child tasks based on their own inter-task dependencies. The epic stays open until all children are Done.\n\n**What OpenSprint's orchestration layer adds:**\n\n- Agent lifecycle management (spawn, monitor, 10-min timeout, teardown)\n- Context assembly with Summarizer invocation when thresholds exceeded\n- Two-agent Coder/Reviewer cycle (Section 7.3.2, 12.5)\n- Retry and progressive backoff (Section 9)\n- Serialized git commit queue for all main-branch operations (Section 5.9)\n- Explicit beads persistence (`bd export` at defined checkpoints)\n\n### 5.5 Orchestrator Trust Boundary\n\n**The orchestrator is a deterministic Node.js process — it executes scripted logic, never LLM inference.** Agents are non-deterministic and may omit, misinterpret, or fail to execute instructions, or be terminated unexpectedly. Any operation that affects project state, version control, or workflow progression must be performed by the orchestrator in code — never delegated to agent prompts.\n\n**Critical operations (orchestrator-only):**\n\n| Operation                    | Phase(s)   | Why Orchestrator Must Own It                                                                                                 |\n| ---------------------------- | ---------- | ---------------------------------------------------------------------------------------------------------------------------- |\n| Worktree + branch management | Execute    | Agent might leave repo in inconsistent state; worktree creation/cleanup must be deterministic                                |\n| Committing and merging       | Execute    | Agent might forget, commit partially, or merge incorrectly; all git ops on main serialized via commit queue (Section 5.9)    |\n| Triggering the next agent    | All        | Agents have no mechanism to invoke the orchestrator; workflow progression is orchestrator-driven                             |\n| Beads state transitions      | Execute    | `bd update`, `bd close` — invoked by orchestrator based on agent _output_, not agent _actions_                               |\n| Beads issue creation         | Plan, Evaluate | `bd create`, `bd dep add` — agents propose as structured data; orchestrator creates actual issues                            |\n| PRD file updates             | Plan, Evaluate | Agents propose updates; orchestrator writes and commits. **Exception:** Dreamer writes `prd.json` directly (user-supervised) |\n| Gating task closure          | Plan       | \"Execute!\" closes the gate via `bd close` — a scripted action triggered by UI button                                         |\n\n**Agent responsibilities:** Agents produce _outputs_ — code files, `result.json`, structured data (task proposals, PRD updates, feedback categorizations). The orchestrator reads these outputs and performs all corresponding critical operations. Agents never touch git or beads directly.\n\n### 5.6 Data Flow\n\nThe data flows through the system in a unidirectional pipeline with feedback loops. User input in Spec creates or updates the PRD. The PRD is decomposed in Plan into feature-level Plan markdown files, each representing an epic. In Execute, Plan markdowns are further broken into individual tasks mapped to beads for dependency tracking. Agent CLIs pick up tasks, execute them, and report results back through the system. In Evaluate, user feedback is mapped back to the relevant Plan epic and Build tasks, creating new tickets as needed. Any changes at any phase propagate upstream to update the living PRD, ensuring the document always reflects the current state of the project.\n\n### 5.7 Orchestrator Lifecycle & Always-On Loop\n\n**One orchestrator per project, always running.** When the OpenSprint backend starts, it launches an orchestrator instance for each registered project. The orchestrator continuously monitors for available work and dispatches agents — there is no manual \"start build\" action.\n\n**Single-agent constraint applies only to Coder/Reviewer (v1).** Each project runs one Coder or Reviewer at a time. All other agents (Dreamer, Planner, Harmonizer, Analyst, Summarizer, Auditor, Delta Planner) can run concurrently with each other and with the Coder/Reviewer, since they don't touch code branches.\n\n**Event-driven with watchdog polling:** The orchestrator triggers agents on events (task completion, feedback submission, Plan execution). A **watchdog timer** runs every 5 minutes to catch edge cases: it queries `bd ready --json`, checks for a running Coder/Reviewer, starts one if tasks are waiting, and terminates any agent that has been inactive for 10 minutes (Section 9.4).\n\n### 5.8 Orchestrator State Persistence & Recovery\n\nThe orchestrator maintains its state in a local file at `.opensprint/orchestrator-state.json` (added to `.gitignore`). This file is updated atomically on every state transition and contains:\n\n```json\n{\n  \"active_task\": {\n    \"task_id\": \"bd-a3f8.2\",\n    \"phase\": \"coding\",\n    \"agent_pid\": 12345,\n    \"branch\": \"opensprint/bd-a3f8.2\",\n    \"worktree_path\": \".opensprint/worktrees/bd-a3f8.2\",\n    \"started_at\": \"2026-02-14T10:30:00Z\",\n    \"last_output_at\": \"2026-02-14T10:32:15Z\"\n  },\n  \"last_watchdog_run\": \"2026-02-14T10:35:00Z\",\n  \"pending_feedback_categorizations\": []\n}\n```\n\n**Attempt tracking via beads labels:** The cumulative attempt count for each task is stored as a beads label in the format `attempts:<N>` (e.g., `attempts:3`). The orchestrator reads and updates this label via `bd label add <id> attempts:<N>` after each attempt. This keeps attempt history co-located with the task in beads rather than requiring a separate tracking mechanism, and is fast to read without parsing comment history.\n\n**On startup recovery:** The orchestrator reads `orchestrator-state.json`:\n\n1. **No active task:** Normal startup — begin event loop and watchdog.\n2. **Active task, PID alive:** Resume monitoring.\n3. **Active task, PID dead:** Auto-recover — revert worktree (`git -C <worktree_path> reset --hard`), remove worktree and branch, add failure comment to bead, re-queue task as `open`, flush pending beads changes to git (Section 5.9), and resume the loop.\n\n### 5.9 Git Concurrency Control\n\nMultiple concurrent agents trigger operations that commit to git on the main branch: beads JSONL exports, PRD updates, Dreamer writes, and worktree merges. Simultaneous commits would contend on `.git/index.lock`. The solution is a **serialized git commit queue**.\n\n**Beads auto-commit disabled:** During `bd init`, OpenSprint runs `bd config set auto-flush false` and `bd config set auto-commit false`. The daemon still runs for SQLite performance, but the orchestrator explicitly manages persistence via `bd export -o .beads/issues.jsonl` after each batch of `bd` commands.\n\n**Commit queue:** The orchestrator owns all git operations on main through an in-process async FIFO queue with one worker. Any component that needs to commit to main enqueues a job rather than running git commands directly.\n\n| Operation                   | Trigger                                                           | Commit Message Pattern                       |\n| --------------------------- | ----------------------------------------------------------------- | -------------------------------------------- |\n| Beads JSONL export + commit | After task creation batch, status transitions, dependency changes | `beads: <summary of changes>`                |\n| PRD update (Harmonizer)     | After orchestrator writes Harmonizer's proposed updates           | `prd: updated after Plan <plan-id> built`    |\n| PRD update (Dreamer)        | After Dreamer modifies `prd.json` during conversation             | `prd: Spec session update`                   |\n| Worktree merge              | After Reviewer approves a task                                    | `merge: opensprint/<task-id> — <task title>` |\n\nThe Dreamer writes `prd.json` directly but does not commit; the orchestrator detects the change and enqueues a commit job. If a commit job fails, it is retried once; if it fails again, the error is logged and the next job proceeds — in-memory/SQLite state is still correct, and the next successful commit captures accumulated changes.\n\n---",
      "version": 1,
      "updatedAt": "2026-02-17T19:19:10.658Z"
    },
    "feature_list": {
      "content": "### 6.1 Home Screen & Project Management\n\nOpenSprint opens to a home screen that lists all existing projects as cards, each showing the project name, last-modified date, current phase, and overall progress. A prominent \"Create New Project\" button starts the project setup wizard.\n\nOnce inside a project, the project name appears at the top-left of the navbar and functions as a dropdown selector. Clicking it reveals a list of all projects, allowing the user to rapidly switch between projects without returning to the home screen. Theme (light/dark/system) is configurable from project settings (Display section; see 6.6).\n\n### 6.2 Project Setup Wizard\n\nCreating a new project follows a sequential wizard:\n\n1. **Project name** — basic metadata.\n2. **Agent configuration** — select Planning Agent Slot and Coding Agent Slot (see 6.3).\n3. **Deployment configuration** — select deployment mode (see 6.4).\n4. **Human-in-the-loop preferences** — configure autonomy thresholds (see 6.5).\n5. **Repository initialization** — OpenSprint creates a git repo, runs `bd init` to set up beads, configures beads with `auto-flush` and `auto-commit` disabled (see Section 5.9), creates the `.opensprint/` directory structure, and adds `.opensprint/orchestrator-state.json` and `.opensprint/worktrees/` to `.gitignore`.\n\nAfter setup, the user lands directly in the Spec tab.\n\n### 6.3 Agent Configuration\n\nUsers configure two agent slots during project setup. Both use the same invocation mechanism — OpenSprint calls the user-selected agent's API or CLI. The only difference is which agent/model is used.\n\n**Planning Agent Slot** (used by: Dreamer, Planner, Harmonizer, Analyst, Summarizer, Auditor, Delta Planner):\n\n- Powers all non-coding agent roles. Each named agent receives a specialized prompt and produces a role-specific output format (see Section 12), but all share the same underlying model configuration.\n- Options: Claude (select model: e.g., Sonnet, Opus), Cursor (select model from available options), or Custom (user provides CLI command).\n- When Claude or Cursor is selected, OpenSprint queries the provider's API for available models and populates a model dropdown.\n\n**Coding Agent Slot** (used by: Coder, Reviewer):\n\n- Powers task implementation and code review.\n- Same options as Planning Agent Slot, configured independently.\n- Users may choose the same agent/model for both slots, or different ones (e.g., Opus for planning, Sonnet for coding to manage costs).\n\n**Named agent roles:**\n\n| Agent         | Slot     | Phase             | Purpose                                                                    |\n| ------------- | -------- | ----------------- | -------------------------------------------------------------------------- |\n| Dreamer       | Planning | Spec              | Multi-turn PRD creation and refinement via chat                            |\n| Planner       | Planning | Plan              | Decomposes PRD into features and tasks; outputs indexed task list          |\n| Harmonizer    | Planning | Plan (Execute!)   | Reviews shipped Plan against PRD; proposes PRD section updates             |\n| Analyst       | Planning | Evaluate          | Categorizes feedback; maps to epics; proposes new tasks                    |\n| Summarizer    | Planning | Execute           | Condenses context when dependencies or Plan exceed thresholds              |\n| Auditor       | Planning | Plan (Re-execute) | Summarizes current app capabilities from codebase and task history         |\n| Delta Planner | Planning | Plan (Re-execute) | Compares old/new Plan against Auditor's summary; generates delta task list |\n| Coder         | Coding   | Execute           | Implements tasks and writes tests                                          |\n| Reviewer      | Coding   | Execute           | Validates implementation against spec; approves or rejects                 |\n\nThe agent configuration can be changed at any time from project settings. When switching the Coding Agent Slot mid-project, all pending tasks in the Ready state will be picked up by the newly selected agent. In-progress tasks will complete with their originally assigned agent.\n\n### 6.4 Deployment Configuration\n\nOpenSprint supports two deployment modes that users configure during project setup:\n\n- **Expo.dev integration (default for mobile/web):** OpenSprint can automatically deploy to Expo.dev for React Native and web projects. The system manages EAS Build configuration, over-the-air updates, and preview deployments for the Evaluate phase. Each completed Execute cycle triggers an automatic preview deployment. Requires internet connectivity.\n- **Custom deployment pipeline:** Users can connect their own deployment pipeline by specifying a deployment command or webhook URL. OpenSprint will trigger this pipeline after successful Execute completion and test passage. This supports any CI/CD system (GitHub Actions, Vercel, Netlify, AWS, etc.).\n\n### 6.5 Human-in-the-Loop Configuration\n\nOpenSprint is designed to operate as an autonomous flywheel, but users have granular control over when the system pauses for human input. During project setup (and adjustable at any time), users configure their autonomy preferences via a series of checkboxes organized into three decision categories.\n\n#### 6.5.1 Decision Categories\n\n| Category                 | What It Covers                                                                                                                                                                                        | Default           |\n| ------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------ |\n| Scope Changes            | Any modification that adds, removes, or substantially alters a feature in the PRD. This includes changes triggered by Evaluate feedback that the AI determines represent new scope rather than bug fixes. | Requires approval |\n| Architecture Decisions   | Technology stack changes, new external service integrations, database schema modifications, API contract changes, and significant refactors that alter system structure.                              | Requires approval |\n| Dependency Modifications | Changes to task ordering, adding new dependencies between epics, splitting or merging tasks, and re-prioritization of the execution queue.                                                            | Automated         |\n\n**Note:** Test failures and agent errors are always handled automatically via progressive backoff (retry, requeue, deprioritize, and eventually block — see Section 9.1). This is not configurable, as the hands-off recovery strategy is core to the flywheel design.\n\n#### 6.5.2 Notification Behavior\n\nFor each category, users choose one of three modes:\n\n- **Automated:** The AI makes the decision autonomously and notifies the user after the fact via a log entry. The flywheel continues without pausing.\n- **Notify and proceed:** The AI makes the decision, sends a real-time notification to the user, and continues without waiting. The user can review and override retroactively if needed.\n- **Requires approval:** The AI prepares a recommendation with full context, pauses the affected work stream, and waits for explicit user approval before proceeding. Other non-blocked work continues in parallel.\n\n### 6.6 Appearance & Theme\n\nOpenSprint supports Light, Dark, and System (follows OS `prefers-color-scheme`) themes. The preference is global across all projects, persists in `localStorage`, applies immediately to all views, and is configurable from project settings (Display section). System is the default for new users.",
      "version": 2,
      "updatedAt": "2026-02-19T08:47:40.115Z"
    },
    "data_model": {
      "content": "### 10.1 Entity Relationship Overview\n\n```\nUser (implicit, single-user)\n  └── Project (1:many)\n        ├── PRD (1:1, JSON file)\n        ├── AgentConfig (1:1, embedded in project settings)\n        ├── Conversation (1:many, per phase/context)\n        │     └── Message (1:many, ordered)\n        ├── Plan (1:many, markdown files)\n        │     └── Task (1:many, beads issues with parent-child IDs)\n        │           └── AgentSession (1:many, per attempt)\n        ├── FeedbackItem (1:many)\n        ├── DeploymentRecord (1:many)\n        └── Settings (1:1, project configuration)\n```\n\n### 10.2 Entity Definitions\n\n#### Project\n\n| Field         | Type          | Description                           |\n| ------------- | ------------- | ------------------------------------- |\n| id            | string (UUID) | Unique project identifier             |\n| name          | string        | Display name                          |\n| repo_path     | string        | Absolute path to the git repository   |\n| created_at    | datetime      | Creation timestamp                    |\n| updated_at    | datetime      | Last modification timestamp           |\n| current_phase | enum          | spec / plan / execute / eval / deploy |\n\n#### PRD (PRDDocument)\n\nStored as `.opensprint/prd.json`. Top-level fields:\n\n| Field      | Type   | Description                                                                                                                         |\n| ---------- | ------ | ----------------------------------------------------------------------------------------------------------------------------------- |\n| version    | number | Monotonically increasing document version                                                                                           |\n| sections   | object | Keyed by section name (e.g., `executive_summary`); each value has `content` (markdown), `version` (number), `updated_at` (datetime) |\n| change_log | array  | Entries with `section`, `version`, `source` (which phase triggered the change), `timestamp`, `diff`                                 |\n\n#### Conversation\n\nStored as `.opensprint/conversations/<conversation-id>.json`. Created per phase context (one for Spec chat, one per Plan sidebar). Fields: `id`, `context` (spec / plan:\\<plan-id\\>), `messages[]`. Each message: `role` (user/assistant), `content` (markdown), `timestamp`, `prd_changes[]` (optional — PRD sections modified by this message).\n\n#### Plan\n\nStored as `.opensprint/plans/<plan-id>.md` in the project repo. The Plan markdown file is associated to its bead epic as the design document metadata — the epic's `description` field contains the path to the Plan markdown file (e.g., `.opensprint/plans/auth.md`), making the Plan the authoritative specification that agents reference when implementing child tasks. Additional metadata:\n| Field | Type | Description |\n|-------|------|-------------|\n| plan_id | string | Unique identifier (matches filename) |\n| bead_epic_id | string | Corresponding beads epic ID (e.g., `bd-a3f8`). Plan status (planning/building/complete) is derived from the beads epic state — no separate status field needed. |\n| gate_task_id | string | The gating task ID (e.g., `bd-a3f8.0`) — closed when user clicks \"Execute!\" |\n| shipped_at | datetime | When the user clicked \"Execute!\" (null if still in planning) |\n| complexity | enum | low / medium / high / very_high |\n\n#### Task\n\nRepresented as beads issues (child IDs under the Plan's epic). OpenSprint reads/writes these via `bd` commands. Key fields managed by beads:\n| Field | Source | Description |\n|-------|--------|-------------|\n| id | beads | Hash-based ID (e.g., `bd-a3f8.1`) |\n| title | beads | Task title |\n| description | beads | Task specification |\n| status | beads | open / in_progress / closed |\n| priority | beads | 0-4 (0 = highest) |\n| assignee | beads | Agent instance ID when in progress |\n| labels | beads | User-defined labels for categorization |\n| dependencies | beads | `blocks` relationships to other tasks |\n\n#### AgentSession\n\nStored as `.opensprint/sessions/<task-id>-<attempt>.json`. Fields: `task_id`, `attempt`, `agent_type` (claude/cursor/custom), `agent_model`, `started_at`, `completed_at`, `status` (success/failed/timeout/cancelled/approved/rejected), `output_log` (filepath), `git_branch`, `git_diff` (filepath), `test_results`, `failure_reason`.\n\n#### FeedbackItem\n\nStored as `.opensprint/feedback/<feedback-id>.json`. Fields: `id`, `text` (user's natural language feedback), `category` (bug/feature/ux/scope), `mapped_plan_id`, `created_task_ids` (beads IDs created from this feedback), `status` (pending/mapped/resolved), `created_at`.\n\n#### DeploymentRecord\n\nStored as `.opensprint/deployments/<deploy-id>.json`. Fields: `id`, `commit_hash` (git SHA deployed), `target` (staging/production), `mode` (expo/custom), `status` (pending/in_progress/success/failed/rolled_back), `started_at`, `completed_at`, `url` (deployed URL if available), `log_path` (filepath to deployment output log), `rolled_back_by` (deploy ID if this deployment was rolled back).\n\n#### ProjectSettings\n\nStored as `.opensprint/settings.json`. Fields: `planning_agent` ({ type, model, cli_command }), `coding_agent` ({ type, model, cli_command }), `deployment` ({ mode, expo_config, custom_command }), `hil_config` (per-category notification mode), `test_framework`, `test_command` (auto-detected from `package.json`, default: `npm test`, overridable).\n\n**UserPreferences** (frontend-only): Theme stored in `localStorage` at `opensprint.theme` (light/dark/system).\n\n### 10.3 Storage Strategy\n\n**Project Index:** `~/.opensprint/projects.json` maps project IDs to repo paths (`id`, `name`, `repo_path`, `created_at`). This is the only data stored outside project repos.\n\n**Per-Project Data:** All other data lives in the project's git repository: beads issues in `.beads/`, OpenSprint metadata in `.opensprint/`. This means everything is version-controlled, works offline, and syncs via git push/pull. The backend maintains an in-memory index rebuilt from the filesystem on startup.",
      "version": 2,
      "updatedAt": "2026-02-19T08:47:40.115Z"
    },
    "api_contracts": {
      "content": "### 11.1 REST API\n\nAll endpoints are prefixed with `/api/v1`. Responses are JSON.\n\n#### Projects\n\n| Method | Endpoint        | Description                                      |\n| ------ | --------------- | ------------------------------------------------ |\n| GET    | `/projects`     | List all projects                                |\n| POST   | `/projects`     | Create a new project (runs setup wizard backend) |\n| GET    | `/projects/:id` | Get project details                              |\n| PUT    | `/projects/:id` | Update project settings                          |\n| DELETE | `/projects/:id` | Delete a project                                 |\n\n#### PRD\n\n| Method | Endpoint                     | Description                   |\n| ------ | ---------------------------- | ----------------------------- |\n| GET    | `/projects/:id/prd`          | Get full PRD                  |\n| GET    | `/projects/:id/prd/:section` | Get a specific PRD section    |\n| PUT    | `/projects/:id/prd/:section` | Update a specific PRD section |\n| GET    | `/projects/:id/prd/history`  | Get PRD change log            |\n\n#### Plans\n\n| Method | Endpoint                                 | Description                                                  |\n| ------ | ---------------------------------------- | ------------------------------------------------------------ |\n| GET    | `/projects/:id/plans`                    | List all Plans with status                                   |\n| POST   | `/projects/:id/plans`                    | Create a new Plan                                            |\n| GET    | `/projects/:id/plans/:planId`            | Get Plan markdown and metadata                               |\n| PUT    | `/projects/:id/plans/:planId`            | Update Plan markdown                                         |\n| POST   | `/projects/:id/plans/:planId/execute`    | Execute the Plan (transition tasks from Planning to Backlog) |\n| POST   | `/projects/:id/plans/:planId/re-execute` | Re-execute an updated Plan (with confirmation)               |\n| GET    | `/projects/:id/plans/dependencies`       | Get dependency graph data                                    |\n\n#### Tasks (read-through to beads)\n\n| Method | Endpoint                                        | Description                               |\n| ------ | ----------------------------------------------- | ----------------------------------------- |\n| GET    | `/projects/:id/tasks`                           | List all tasks (wraps `bd list --json`)   |\n| GET    | `/projects/:id/tasks/ready`                     | Get ready tasks (wraps `bd ready --json`) |\n| GET    | `/projects/:id/tasks/:taskId`                   | Get task details (wraps `bd show --json`) |\n| GET    | `/projects/:id/tasks/:taskId/sessions`          | Get agent sessions for a task             |\n| GET    | `/projects/:id/tasks/:taskId/sessions/:attempt` | Get specific agent session output         |\n\n#### Execute Orchestration\n\n| Method | Endpoint                       | Description                                                       |\n| ------ | ------------------------------ | ----------------------------------------------------------------- |\n| GET    | `/projects/:id/execute/status` | Get orchestrator status (active agent, current task, queue depth) |\n\n#### Evaluate\n\n| Method | Endpoint                             | Description                           |\n| ------ | ------------------------------------ | ------------------------------------- |\n| GET    | `/projects/:id/feedback`             | List all feedback items               |\n| POST   | `/projects/:id/feedback`             | Submit new feedback                   |\n| GET    | `/projects/:id/feedback/:feedbackId` | Get feedback details and mapped tasks |\n\n#### Deploy\n\n| Method | Endpoint                                  | Description                                 |\n| ------ | ----------------------------------------- | ------------------------------------------- |\n| POST   | `/projects/:id/deploy`                    | Trigger a deployment                        |\n| GET    | `/projects/:id/deploy/status`             | Get current deployment status               |\n| GET    | `/projects/:id/deploy/history`            | List deployment history                     |\n| POST   | `/projects/:id/deploy/:deployId/rollback` | Roll back to a previous deployment          |\n| PUT    | `/projects/:id/deploy/settings`           | Update deployment environment configuration |\n\n#### Chat (Spec & Plan conversation)\n\n| Method | Endpoint                     | Description                                                 |\n| ------ | ---------------------------- | ----------------------------------------------------------- |\n| POST   | `/projects/:id/chat`         | Send a message to the Dreamer agent; returns agent response |\n| GET    | `/projects/:id/chat/history` | Get conversation history                                    |\n\n### 11.2 WebSocket Events\n\nConnection: `ws://localhost:<port>/ws/projects/:id`\n\n**Server → Client events:**\n| Event | Payload | Description |\n|-------|---------|-------------|\n| `task.updated` | `{ taskId, status, assignee }` | Task state changed |\n| `task.blocked` | `{ taskId, totalAttempts, lastFailureReason }` | Task blocked after exhausting all retry/deprioritization levels; requires user attention |\n| `agent.output` | `{ taskId, chunk }` | Streaming agent output for a task |\n| `agent.completed` | `{ taskId, status, testResults }` | Agent finished a task |\n| `prd.updated` | `{ section, version }` | PRD section was updated |\n| `execute.status` | `{ currentTask, queueDepth }` | Orchestrator status change |\n| `hil.request` | `{ category, description, options }` | Human-in-the-loop approval needed |\n| `feedback.mapped` | `{ feedbackId, planId, taskIds }` | Feedback was mapped to tasks |\n| `deploy.started` | `{ deployId, target, commitHash }` | Deployment started |\n| `deploy.completed` | `{ deployId, status, url }` | Deployment finished (success or failed) |\n| `deploy.output` | `{ deployId, chunk }` | Streaming deployment log output |\n\n**Client → Server events:**\n| Event | Payload | Description |\n|-------|---------|-------------|\n| `agent.subscribe` | `{ taskId }` | Start streaming agent output for a task |\n| `agent.unsubscribe` | `{ taskId }` | Stop streaming agent output |\n| `hil.respond` | `{ requestId, approved, notes }` | Respond to a HIL request |\n\n---\n\n---\n\n### 12.1 Overview\n\nThe orchestration layer communicates with agents through a standardized file-based interface. Each named agent role (see Section 6.3) receives a role-specific prompt and produces a role-specific output, but all share the same invocation and directory mechanism. Agents in the **Coding Agent Slot** (Coder, Reviewer) operate in git worktrees and are subject to the single-agent constraint. Agents in the **Planning Agent Slot** (Dreamer, Planner, Harmonizer, Analyst, Summarizer, Auditor, Delta Planner) can run concurrently.\n\n### 12.2 Common Input Structure\n\nFor all agent invocations, the orchestrator creates a task directory at `.opensprint/active/<invocation-id>/` containing:\n\n```\n.opensprint/active/<invocation-id>/\n├── prompt.md           # Role-specific prompt (see 12.3)\n├── context/            # Role-specific context files\n└── config.json         # Invocation configuration\n```\n\n**config.json** always includes `invocation_id`, `agent_role`, and `repo_path`. Each agent contract below documents only the role-specific additional fields.\n\n**Default status values:** Unless otherwise noted, all planning-slot agents produce `result.json` with status `\"success\"` or `\"failed\"`. Some agents add additional values (e.g., `\"no_changes_needed\"`) as documented in their contract.\n\n### 12.3 Agent Contracts\n\n#### 12.3.1 Dreamer\n\n**Purpose:** Multi-turn conversational PRD creation and refinement.\n\nThe Dreamer is unique — it runs as a persistent, interactive session (not a one-shot task). Each turn receives `context/prd.json`, `context/conversation_history.json`, and the user's new message. When used for Plan sidebar chat, `config.json` includes `scope: \"plan\"` and a `plan_path` field.\n\n**Output:** Streams conversational responses to stdout (relayed via WebSocket) and **updates `prd.json` directly** — the one trust boundary exception (Section 5.5), acceptable because the user observes every change in real-time.\n\n#### 12.3.2 Planner\n\n**Purpose:** Decompose a Plan into features and tasks.\n\n**Input:** `context/prd.json`, `context/plan.md`. **Additional config:** `plan_id`, `epic_id`.\n\n**Output (`result.json`):**\n\n```json\n{\n  \"status\": \"success\",\n  \"tasks\": [\n    {\n      \"index\": 0,\n      \"title\": \"Set up database schema\",\n      \"description\": \"...\",\n      \"priority\": 1,\n      \"depends_on\": []\n    },\n    {\n      \"index\": 1,\n      \"title\": \"Implement user model\",\n      \"description\": \"...\",\n      \"priority\": 1,\n      \"depends_on\": [0]\n    },\n    {\n      \"index\": 2,\n      \"title\": \"Build auth endpoints\",\n      \"description\": \"...\",\n      \"priority\": 2,\n      \"depends_on\": [0, 1]\n    }\n  ]\n}\n```\n\nThe orchestrator creates beads issues from this output, resolving ordinal indices to actual beads IDs (see Section 7.2.2).\n\n#### 12.3.3 Harmonizer\n\n**Purpose:** Review a shipped Plan against the PRD and propose section updates.\n\n**Input:** `context/prd.json`, `context/plan.md`. **Additional config:** `plan_id`, `trigger` (`\"build_it\"` or `\"scope_change\"`).\n\n**Output (`result.json`):** `{ \"status\": \"success\", \"prd_updates\": [{ \"section\": \"<name>\", \"action\": \"update\", \"content\": \"<markdown>\", \"change_log_entry\": \"<description>\" }] }`. **Additional status:** `no_changes_needed`.\n\n#### 12.3.4 Analyst\n\n**Purpose:** Categorize user feedback and map it to the appropriate Plan epic and tasks.\n\n**Input:** `context/prd.json`, `context/plans_index.json`, `context/feedback.txt`. **Additional config:** `feedback_id`.\n\n**Output (`result.json`):** `{ \"status\": \"success\", \"category\": \"<bug|feature|ux|scope>\", \"mapped_plan_id\": \"<id>\", \"mapped_epic_id\": \"<id>\", \"proposed_tasks\": [<indexed task list, same format as Planner>], \"is_scope_change\": <bool> }`. When `is_scope_change` is `true`, the orchestrator also invokes the Harmonizer with `trigger: \"scope_change\"`.\n\n#### 12.3.5 Summarizer\n\n**Purpose:** Condense context into a focused summary when thresholds are exceeded (>2 dependencies or >2,000-word Plan).\n\n**Input:** `context/prd_excerpt.md`, `context/plan.md`, `context/deps/`. **Additional config:** `task_id`, `dependency_count`, `plan_word_count`.\n\n**Output (`result.json`):** `{ \"status\": \"success\", \"summary\": \"<markdown>\" }` — a condensed context preserving architectural decisions, interface contracts, and key implementation details. The orchestrator replaces the raw context files with this summary when assembling the Coder's prompt.\n\n#### 12.3.6 Auditor\n\n**Purpose:** Summarize the current app's capabilities for a Plan being re-built.\n\n**Input:** `context/file_tree.txt`, `context/key_files/`, `context/completed_tasks.json`. **Additional config:** `plan_id`, `epic_id`.\n\n**Output (`result.json`):** `{ \"status\": \"success\", \"capability_summary\": \"<markdown>\" }` — a structured summary of implemented features, data models, and API surface relevant to this epic.\n\n#### 12.3.7 Delta Planner\n\n**Purpose:** Compare old and new Plan versions against the Auditor's capability summary and generate only the delta tasks needed.\n\n**Input:** `context/plan_old.md`, `context/plan_new.md`, `context/capability_summary.md`. **Additional config:** `plan_id`, `epic_id`.\n\n**Output (`result.json`):** Same format as the Planner (Section 12.3.2) — an indexed task list with dependencies. **Additional status:** `no_changes_needed`.\n\n#### 12.3.8 Coder\n\n**Purpose:** Implement a task and write tests.\n\n**Input:** `context/plan.md` (or Summarizer output), `context/prd_excerpt.md`, `context/deps/`. **Additional config:** `task_id`, `branch`, `worktree_path`, `test_command`, `attempt`, `previous_failure`, `review_feedback`.\n\n**Prompt (`prompt.md`):**\n\n```markdown\n# Task: <task title>\n\n## Objective\n\n<task description from beads>\n\n## Context\n\nYou are implementing a task as part of a larger feature. Review the provided context files:\n\n- `context/plan.md` — the full feature specification\n- `context/prd_excerpt.md` — relevant product requirements\n- `context/deps/` — output from tasks this depends on\n\n## Acceptance Criteria\n\n<from the Plan markdown>\n\n## Technical Approach\n\n<from the Plan markdown>\n\n## Instructions\n\n1. Work in the worktree at `<worktree_path>` (already set up by the orchestrator).\n2. Implement the task according to the acceptance criteria.\n3. Write comprehensive tests (unit, and integration where applicable).\n4. Run `<test_command>` and ensure all tests pass.\n5. Do NOT commit — the orchestrator will commit your changes after you exit.\n6. Write your completion summary to `.opensprint/active/<invocation-id>/result.json`.\n\n## Previous Attempt (if retry)\n\n<failure reason and output from previous attempt, if applicable>\n\n## Review Feedback (if re-implementation after Reviewer rejection)\n\n<Reviewer's rejection comments, if applicable>\n```\n\n**Output (`result.json`):**\n\n```json\n{\n  \"status\": \"success\",\n  \"summary\": \"Implemented user authentication endpoint with JWT token generation and validation.\",\n  \"files_changed\": [\"src/auth/controller.ts\", \"src/auth/service.ts\", \"tests/auth/auth.test.ts\"],\n  \"tests_written\": 12,\n  \"tests_passed\": 12,\n  \"notes\": \"Used bcrypt for password hashing. Rate limiting added as noted in the Plan.\"\n}\n```\n\n**Status values:** `success`, `failed`, `partial` (some work done but blocked on an issue).\n\n#### 12.3.9 Reviewer\n\n**Purpose:** Validate a Coder's implementation against the task specification.\n\n**Input:** Same context files as the Coder. **Additional config:** same as Coder minus `attempt`, `previous_failure`, `review_feedback`.\n\n**Prompt:** Same structure as the Coder prompt (Objective, Acceptance Criteria, Context) with these differences: the Instructions section directs the Reviewer to (1) review the diff via `git diff main...<branch>`, (2) verify all acceptance criteria are met, (3) verify tests cover the ticket scope beyond happy paths, (4) run `<test_command>`, (5) check code quality, and (6) write `result.json` with status `\"approved\"` or `\"rejected\"`. The Reviewer does NOT merge — the orchestrator merges after approval.\n\n**Output (`result.json`):** On approval: `{ \"status\": \"approved\", \"summary\": \"...\", \"notes\": \"...\" }`. On rejection: `{ \"status\": \"rejected\", \"summary\": \"...\", \"issues\": [\"...\"], \"notes\": \"...\" }` with specific, actionable feedback.\n\nIf any agent does not produce a `result.json` (crash/timeout), the orchestrator treats it as a failure and follows the error handling flow in Section 9.\n\n### 12.4 Invocation\n\nThe orchestrator invokes agents as subprocesses: `claude --task-file <path>`, `cursor-agent --input <path>`, or `<custom-command> <path>` where `<path>` is `.opensprint/active/<invocation-id>/prompt.md`. The Dreamer uses the same CLI in interactive/streaming mode. Agent stdout/stderr is streamed to the frontend via WebSocket. The 10-minute inactivity timeout (Section 9.4) applies to Coder/Reviewer only.\n\n### 12.5 Completion Detection & Flow\n\n**Worktree management:** Each Coder task runs in a dedicated worktree created via `git worktree add .opensprint/worktrees/<task-id> -b opensprint/<task-id>`. The Reviewer operates in the same worktree. After approval, the orchestrator merges to main and removes the worktree. Beads commands run from the main repo root.\n\n**Coding phase:**\n\n1. The orchestrator creates the worktree and sets up the task directory.\n2. The Coder CLI process is invoked and runs in the worktree.\n3. When the process exits, the orchestrator checks for `result.json`.\n4. If `status` is `success`, the orchestrator commits all changes in the worktree (Coder does not commit), then runs the test command as a sanity check.\n5. If tests pass, the task moves to In Review and the Reviewer is triggered (same worktree).\n6. If tests fail or `status` is `failed`, the error handling flow (Section 9.2) is triggered.\n\n**Review phase:**\n\n1. The Reviewer CLI process is invoked. It reviews the diff via `git diff main...<branch>`.\n2. When the process exits, the orchestrator checks for `result.json`.\n3. If `status` is `approved`, the orchestrator merges the task branch to main, marks the task Done in beads, and removes the worktree. The Reviewer never performs the merge.\n4. If `status` is `rejected`, the rejection feedback is added as a comment on the bead issue, and a new Coder is triggered in the same worktree with the feedback included in the prompt.\n\n**Archival:** After a task reaches Done (or exhausts retries), the task directory is moved to `.opensprint/sessions/<task-id>-<attempt>/` for archival.\n\n---",
      "version": 1,
      "updatedAt": "2026-02-17T19:19:10.658Z"
    },
    "non_functional_requirements": {
      "content": "| Category        | Requirement                                                                                                 |\n| --------------- | ----------------------------------------------------------------------------------------------------------- |\n| Performance     | Real-time agent output streaming with < 500ms latency; task status updates within 1 second of state changes |\n| Scalability     | Handle projects with up to 500 tasks; single Coder/Reviewer in v1, concurrent Coders planned for v2         |\n| Reliability     | Agent failures must not corrupt project state; all state changes are transactional and recoverable          |\n| Security        | Code execution in sandboxed environments; user projects isolated at the filesystem level                    |\n| Usability       | First-time users can create a Spec and reach Execute phase within 30 minutes without documentation          |\n| Theme Support   | Light, dark, and system themes; preference persists across sessions; no flash of wrong theme on load        |\n| Data Integrity  | Full audit trail of every change via PRD versioning and bead provenance; no data loss on agent crash        |\n| Testing         | Minimum 80% code coverage; all test layers automated; test results visible in real-time                     |\n| Offline Support | All core features (Spec, Plan, Execute, Evaluate, Deploy) fully functional without internet connectivity        |\n\n---",
      "version": 1,
      "updatedAt": "2026-02-17T19:19:10.658Z"
    },
    "open_questions": {
      "content": "_No open questions at this time. All previously identified questions have been resolved and documented in Section 18._\n\n---\n\n_End of Document_",
      "version": 1,
      "updatedAt": "2026-02-17T19:19:10.658Z"
    }
  },
  "changeLog": [
    {
      "section": "executive_summary",
      "version": 1,
      "source": "spec",
      "timestamp": "2026-02-17T19:19:10.658Z",
      "diff": "[PRD.md sync: executive_summary]"
    },
    {
      "section": "problem_statement",
      "version": 1,
      "source": "spec",
      "timestamp": "2026-02-17T19:19:10.658Z",
      "diff": "[PRD.md sync: problem_statement]"
    },
    {
      "section": "goals_and_metrics",
      "version": 1,
      "source": "spec",
      "timestamp": "2026-02-17T19:19:10.658Z",
      "diff": "[PRD.md sync: goals_and_metrics]"
    },
    {
      "section": "user_personas",
      "version": 1,
      "source": "spec",
      "timestamp": "2026-02-17T19:19:10.658Z",
      "diff": "[PRD.md sync: user_personas]"
    },
    {
      "section": "technical_architecture",
      "version": 1,
      "source": "spec",
      "timestamp": "2026-02-17T19:19:10.658Z",
      "diff": "[PRD.md sync: technical_architecture]"
    },
    {
      "section": "feature_list",
      "version": 1,
      "source": "spec",
      "timestamp": "2026-02-17T19:19:10.658Z",
      "diff": "[PRD.md sync: feature_list]"
    },
    {
      "section": "data_model",
      "version": 1,
      "source": "spec",
      "timestamp": "2026-02-17T19:19:10.658Z",
      "diff": "[PRD.md sync: data_model]"
    },
    {
      "section": "api_contracts",
      "version": 1,
      "source": "spec",
      "timestamp": "2026-02-17T19:19:10.658Z",
      "diff": "[PRD.md sync: api_contracts]"
    },
    {
      "section": "non_functional_requirements",
      "version": 1,
      "source": "spec",
      "timestamp": "2026-02-17T19:19:10.658Z",
      "diff": "[PRD.md sync: non_functional_requirements]"
    },
    {
      "section": "open_questions",
      "version": 1,
      "source": "spec",
      "timestamp": "2026-02-17T19:19:10.658Z",
      "diff": "[PRD.md sync: open_questions]"
    },
    {
      "section": "feature_list",
      "version": 2,
      "source": "eval",
      "timestamp": "2026-02-19T08:47:40.115Z",
      "diff": "[-230 lines, -26101 chars]"
    },
    {
      "section": "data_model",
      "version": 2,
      "source": "eval",
      "timestamp": "2026-02-19T08:47:40.115Z",
      "diff": "[-3 lines, -79 chars]"
    }
  ]
}