{
  "version": 7,
  "sections": {
    "executive_summary": {
      "content": "OpenSprint is a web application that guides users through the complete software development lifecycle using AI agents. It provides a structured, five-phase workflow — **SPEED**: Sketch, Plan, Execute, Evaluate, and Deliver — that transforms high-level product ideas into working software with minimal manual intervention.\n\nThe platform pairs a browser-based interface with a background agent CLI, enabling AI to autonomously execute development tasks while keeping the user in control of strategy and direction. The core philosophy is that humans should focus on _what_ to build and _why_, while AI handles _how_ to build it.\n\nOpenSprint supports multiple agent backends (Claude, Cursor, and custom CLI agents), comprehensive automated testing including end-to-end and integration tests, configurable human-in-the-loop thresholds, and full offline operation for users with local agent setups.",
      "version": 1,
      "updatedAt": "2026-02-25T00:03:38.391Z"
    },
    "problem_statement": {
      "content": "Building software with AI today is fragmented and unstructured. Developers use AI coding assistants for individual tasks, but there is no cohesive system that manages the full journey from idea to deployed product. This leads to several persistent problems:\n\n- **Lack of architectural coherence:** AI-generated code often lacks a unified vision because each prompt is handled in isolation, without awareness of the broader system design.\n- **No dependency tracking:** When building features in parallel, there is no mechanism to ensure that work on one feature accounts for dependencies on another.\n- **Manual orchestration overhead:** Users spend significant time managing prompts, context windows, and task sequencing rather than focusing on product decisions.\n- **No feedback loop:** There is no structured way to validate completed work and feed findings back into the development process.\n\nOpenSprint solves these problems by providing an end-to-end platform that maintains context across the entire lifecycle and automates the orchestration of AI development agents.",
      "version": 1,
      "updatedAt": "2026-02-25T00:03:38.391Z"
    },
    "user_personas": {
      "content": "### The Product-Minded Founder\n\nA non-technical founder with a clear product vision who wants to build an MVP without hiring a development team. They understand what they want to build but need AI to handle the engineering. They value speed, clear communication about what is being built, and the ability to provide feedback without writing code.\n\n### The Solo Developer\n\nAn experienced developer who wants to multiply their output. They can code but want to delegate routine implementation to AI while focusing on architecture and product decisions. They value transparency into what the AI is doing, the ability to intervene when needed, and high-quality code output.\n\n### The Agency / Consultancy\n\nA small team that builds software for clients. They need to move quickly from client requirements to working software, maintain multiple projects simultaneously, and provide clients with visibility into progress. They value the structured workflow for client communication and the ability to run multiple projects in parallel.",
      "version": 1,
      "updatedAt": "2026-02-25T00:03:38.391Z"
    },
    "goals_and_metrics": {
      "content": "### Primary Goals\n\n1. Reduce the time from idea to working prototype by 10x compared to traditional AI-assisted development workflows.\n2. Enable non-engineers to ship production-quality software by handling technical complexity behind the scenes.\n3. Maintain architectural coherence across an entire project by flowing design decisions through every phase.\n4. Create a self-improving development flywheel where validation feedback automatically triggers corrective action.\n\n### Success Metrics\n\n| Metric                                | Target                                     | Measurement Method                 |\n| ------------------------------------- | ------------------------------------------ | ---------------------------------- |\n| Time from idea to working prototype   | < 1 day for standard web apps              | End-to-end session timing          |\n| User intervention rate during Execute | < 10% of tasks require manual input        | Task completion telemetry          |\n| Sketch-to-code fidelity               | > 90% alignment with PRD                   | Automated PRD compliance checks    |\n| Feedback loop closure time            | < 30 min from bug report to fix deployed   | Evaluate-to-Execute cycle tracking |\n| First-time user task completion       | > 80% complete a full Sketch-Execute cycle | Onboarding funnel analytics        |\n| Test coverage                         | > 80% code coverage with passing E2E tests | Automated coverage reporting       |",
      "version": 1,
      "updatedAt": "2026-02-25T00:03:38.391Z"
    },
    "feature_list": {
      "content": "Add under Project Setup & Configuration:\n\n- **Help modal (?):** Available on both homepage and per-project view. Two tabs: \"Ask a Question\" (default) and \"Meet your Team\". Ask a Question is a chat area with an AI agent in ask-only mode — explicitly instructed to answer only, never to change project state, PRD, or tasks. The agent receives project context when in per-project view (PRD, Plans, tasks, current agent status) or summary info about all projects when on homepage. Includes instructions for accessing more information about projects, tasks, and currently running agents. Meet your Team displays configured agents and their roles.\n\n- **AGENTS.md editor in Agent Config:** Project Settings → Agent Config includes a section to view (rendered markdown) and edit the project's AGENTS.md file in the repo root. Changes are saved via API; enables users to customize project-specific agent instructions without leaving the UI.\n\n- **Global API keys:** API keys are stored only in `~/.opensprint/global-settings.json` and managed from the Settings page (homepage). Users add, edit, and remove multiple keys per provider (ANTHROPIC_API_KEY, CURSOR_API_KEY). When a key hits its rate limit, the system records `limitHitAt` and rotates to the next available key; rate-limited keys become available again after 24 hours. Project Settings → Agent Config does not include an API Keys section; when Claude API or Cursor is selected and no global key exists, a link navigates to Settings. API key modal flow (when keys missing) routes to /settings.\n\nAdd under Evaluate:\n\n- **Feedback link to existing tasks:** When the Analyst categorizes feedback, it receives a list of open tasks and may link feedback to existing tasks instead of creating new ones, reducing ticket proliferation. Tasks may have multiple linked feedback items; the Execute sidebar displays all of them.",
      "version": 6,
      "updatedAt": "2026-03-01T17:59:55.413Z"
    },
    "technical_architecture": {
      "content": "### Architecture Overview\n\nThree primary layers: web frontend, backend API server, and background agent CLI. Frontend uses WebSockets for real-time updates and REST for CRUD. Backend orchestrates agent CLIs, manages project state, and maintains the living PRD. Fully offline-capable with local agents.\n\n### Technology Stack\n\n- **Backend:** Node.js + TypeScript (subprocess management, WebSocket, beads CLI via `child_process.exec()`)\n- **Frontend:** React + TypeScript\n- **Task store:** Beads (git-based, CLI `bd` with `--json`)\n- **Version control:** Git, branch-per-task; Worktree mode: isolated worktrees; Branches mode: main repo with task branches (configurable in Agent Config)\n\n### Core Components\n\n| Component           | Responsibility |\n| ------------------- | -------------- |\n| Web Frontend        | UI for all five phases; real-time agent monitoring |\n| Backend API         | Project state, WebSocket relay, PRD versioning, agent orchestration |\n| Agent CLI           | Code generation, testing, debugging (Claude/Cursor/Custom) |\n| Orchestration Layer | Deterministic Node.js; agent lifecycle; git/task ops; commit queue; watchdog |\n| Beads               | Issue CRUD, dependencies, `bd ready`, assignee, hierarchical IDs |\n| Test Runner         | Jest, Playwright, etc. — auto-detected from `package.json` |\n| Deployment          | Expo.dev or custom pipeline |\n\n### Orchestrator Trust Boundary\n\nOrchestrator owns: worktree/branch management (Worktree mode) or branch-only management (Branches mode), commits/merges, agent triggering, beads state transitions, beads issue creation, PRD updates (except Dreamer direct write), gating task closure. Agents produce outputs; orchestrator performs all critical operations.\n\n### Data Flow\n\nSketch → PRD. Plan → Plan markdowns (epics). Execute → tasks in beads. Agent CLIs execute tasks. Evaluate → feedback mapped to epics/tasks or linked to existing open tasks when the Analyst determines feedback is covered by them. Changes propagate upstream to PRD.\n\n### Orchestrator Lifecycle\n\nOne orchestrator per project, always on. Single Coder/Reviewer at a time (v1); Planning-slot agents concurrent. Event-driven + 5-min watchdog. State in `.opensprint/orchestrator-state.json`; recovery on crash.\n\n### Git Concurrency\n\nSerialized commit queue for main-branch ops. Beads auto-commit disabled; orchestrator manages persistence.",
      "version": 3,
      "updatedAt": "2026-02-25T23:47:10.307Z"
    },
    "data_model": {
      "content": "### 10.1 Entity Relationship Overview\n\n```\nUser (implicit, single-user)\n  └── Project (1:many)\n        ├── PRD (1:1, JSON file)\n        ├── AgentConfig (1:1, embedded in project settings)\n        ├── Conversation (1:many, per phase/context)\n        │     └── Message (1:many, ordered)\n        ├── Plan (1:many, markdown files)\n        │     └── Task (1:many, tasks with parent-child IDs e.g. os-xxxx.1)\n        │           └── AgentSession (1:many, per attempt)\n        ├── FeedbackItem (1:many)\n        ├── DeploymentRecord (1:many)\n        └── Settings (1:1, project configuration, stored in global database)\n```\n\n### 10.2 Entity Definitions\n\n#### Project\n\n| Field         | Type          | Description                              |\n| ------------- | ------------- | ---------------------------------------- |\n| id            | string (UUID) | Unique project identifier                |\n| name          | string        | Display name                             |\n| repo_path     | string        | Absolute path to the git repository      |\n| created_at    | datetime      | Creation timestamp                       |\n| updated_at    | datetime      | Last modification timestamp              |\n| current_phase | enum          | sketch / plan / execute / eval / deliver |\n\n#### PRD (PRDDocument)\n\nStored as `.opensprint/prd.json`. Top-level fields:\n\n| Field      | Type   | Description                                                                                                                         |\n| ---------- | ------ | ----------------------------------------------------------------------------------------------------------------------------------- |\n| version    | number | Monotonically increasing document version                                                                                           |\n| sections   | object | Keyed by section name (e.g., `executive_summary`); each value has `content` (markdown), `version` (number), `updated_at` (datetime) |\n| change_log | array  | Entries with `section`, `version`, `source` (which phase triggered the change), `timestamp`, `diff`                                 |\n\n#### Conversation\n\nStored as `.opensprint/conversations/<conversation-id>.json`. Created per phase context (one for Sketch chat, one per Plan sidebar). Fields: `id`, `context` (sketch / plan:\\<plan-id\\>), `messages[]`. Each message: `role` (user/assistant), `content` (markdown), `timestamp`, `prd_changes[]` (optional — PRD sections modified by this message).\n\n#### Plan\n\nStored as `.opensprint/plans/<plan-id>.md` in the project repo. The Plan markdown file is associated to its epic as the design document metadata — the epic's `description` field contains the path to the Plan markdown file (e.g., `.opensprint/plans/auth.md`), making the Plan the authoritative specification that agents reference when implementing child tasks. Additional metadata:\n| Field | Type | Description |\n|-------|------|-------------|\n| plan_id | string | Unique identifier (matches filename) |\n| epic_id | string | Corresponding epic (task) ID (e.g., `os-a3f8`). Plan status (planning/building/complete) is derived from epic status and task completion: planning = epic blocked; building = epic open + tasks pending; complete = all done. |\n| shipped_at | datetime | When the user clicked \"Execute!\" (null if still in planning) |\n| complexity | enum | low / medium / high / very_high |\n\n#### Task\n\nRepresented as tasks (child IDs under the Plan's epic, e.g. `os-a3f8.1`). OpenSprint reads/writes these via `TaskStoreService`. Key fields:\n\n| Field        | Description                                                                                                               |\n| ------------ | ------------------------------------------------------------------------------------------------------------------------- |\n| id           | Task ID (e.g., `os-a3f8.1`)                                                                                               |\n| title        | Task title                                                                                                                |\n| description  | Task specification                                                                                                        |\n| status       | open / in_progress / closed / blocked. Epic tasks: `blocked` = plan not approved; `open` = approved; `closed` = complete. |\n| priority     | 0-4 (0 = highest)                                                                                                         |\n| assignee     | Agent instance ID when in progress                                                                                        |\n| labels       | User-defined labels for categorization                                                                                    |\n| dependencies | `blocks` relationships to other tasks                                                                                     |\n\n#### AgentSession\n\nStored as `.opensprint/sessions/<task-id>-<attempt>.json`. Fields: `task_id`, `attempt`, `agent_type` (claude/cursor/custom), `agent_model`, `started_at`, `completed_at`, `status` (success/failed/timeout/cancelled/approved/rejected), `output_log` (filepath), `git_branch`, `git_diff` (filepath), `test_results`, `failure_reason`.\n\n#### FeedbackItem\n\nStored as `.opensprint/feedback/<feedback-id>.json`. Fields: `id`, `text` (user's natural language feedback), `category` (bug/feature/ux/scope), `mapped_plan_id`, `created_task_ids` (task IDs created from this feedback), `status` (pending/mapped/resolved), `created_at`.\n\n#### DeploymentRecord\n\nStored as `.opensprint/deployments/<deploy-id>.json`. Fields: `id`, `commit_hash` (git SHA deployed), `target` (staging/production), `mode` (expo/custom), `status` (pending/in_progress/success/failed/rolled_back), `started_at`, `completed_at`, `url` (deployed URL if available), `log_path` (filepath to deployment output log), `rolled_back_by` (deploy ID if this deployment was rolled back).\n\n#### GlobalSettings\n\nStored at `~/.opensprint/global-settings.json`. Single source of truth for API keys and database URL. Fields: `databaseUrl` (PostgreSQL connection URL), `apiKeys` (per-provider arrays: ANTHROPIC_API_KEY, CURSOR_API_KEY). Each API key entry: `id`, `value` (never exposed in API responses), `limitHitAt` (when rate-limited; keys become available again after 24h). ApiKeyResolver reads only from global store and process.env; automatic rotation when a key hits its rate limit.\n\n#### ProjectSettings\n\nStored in the global database (~/.opensprint/), keyed by project ID. Not in per-project files. Does **not** include apiKeys — API keys are managed globally in GlobalSettings. Fields: `planning_agent` ({ type, model, cli_command }), `coding_agent` ({ type, model, cli_command }), `deployment` ({ mode, expo_config, custom_command }), `hil_config` (per-category notification mode), `test_framework`, `test_command` (auto-detected from `package.json`, default: `npm test`, overridable).\n\n**UserPreferences** (frontend-only): Theme stored in `localStorage` at `opensprint.theme` (light/dark/system).\n\n### 10.3 Storage Strategy\n\n**Global Database:** `~/.opensprint/` stores project index, project settings (keyed by project ID), and task data (`tasks.db`). Settings are not stored in per-project files.\n\n**Global Settings File:** `~/.opensprint/global-settings.json` stores `databaseUrl` and `apiKeys`. API keys are never stored in project settings.\n\n**Project Index:** `~/.opensprint/projects.json` maps project IDs to repo paths (`id`, `name`, `repo_path`, `created_at`).\n\n**Per-Project Data:** OpenSprint metadata lives in the project's `.opensprint/` directory (version-controlled): PRD, plans, conversations, feedback, deployments, sessions. No settings.json. Task data lives in the global store `~/.opensprint/tasks.db` and is not in the repo. AGENTS.md in the repo root stores project-specific agent instructions; editable via the agents instructions API. The backend maintains an in-memory index rebuilt from the filesystem on startup.",
      "version": 6,
      "updatedAt": "2026-03-01T17:59:55.413Z"
    },
    "api_contracts": {
      "content": "### REST API (`/api/v1`)\n\n**Projects:** GET/POST `/projects`, GET/PUT/DELETE `/projects/:id`\n\n**Project Settings:** GET/PUT `/projects/:id/settings` — Project settings (agent config, deployment, HIL, etc.). Does **not** include apiKeys; API keys are managed via global-settings only.\n\n**Global Settings:** GET/PUT `/global-settings` — Returns and accepts `databaseUrl` (masked in response) and `apiKeys` (masked: `{id, masked, limitHitAt}` per provider). Supports multiple keys per provider (ANTHROPIC_API_KEY, CURSOR_API_KEY); merge semantics on PUT (preserve existing when value omitted).\n\n**PRD:** GET/PUT `/projects/:id/prd`, GET `/projects/:id/prd/:section`, GET `/projects/:id/prd/history`\n\n**Plans:** GET/POST `/projects/:id/plans`, GET/PUT `/projects/:id/plans/:planId`, POST `/projects/:id/plans/:planId/execute`, POST `/projects/:id/plans/:planId/re-execute`, GET `/projects/:id/plans/dependencies`\n\n**Tasks:** GET `/projects/:id/tasks`, GET `/projects/:id/tasks/ready`, GET `/projects/:id/tasks/:taskId`, GET `/projects/:id/tasks/:taskId/sessions`, GET `/projects/:id/tasks/:taskId/sessions/:attempt`. Task responses include `sourceFeedbackIds?: string[]` when the task has linked feedback (derived from discovered-from dependencies).\n\n**Execute:** GET `/projects/:id/execute/status`\n\n**Evaluate:** GET/POST `/projects/:id/feedback`, GET `/projects/:id/feedback/:feedbackId`\n\n**Deploy:** POST `/projects/:id/deploy`, GET `/projects/:id/deploy/status`, GET `/projects/:id/deploy/history`, POST `/projects/:id/deploy/:deployId/rollback`, PUT `/projects/:id/deploy/settings`\n\n**Chat:** POST `/projects/:id/chat`, GET `/projects/:id/chat/history`\n\n**Agents:** GET `/projects/:id/agents/instructions` — Returns `{ content: string }` (AGENTS.md). PUT `/projects/:id/agents/instructions` — Body `{ content: string }`, writes to repo root AGENTS.md.\n\n### WebSocket (`ws://localhost:<port>/ws/projects/:id`)\n\n**Server → Client:** `task.updated`, `task.blocked`, `agent.output`, `agent.completed`, `prd.updated`, `execute.status`, `hil.request`, `feedback.mapped`, `deploy.started`, `deploy.completed`, `deploy.output`\n\n**Client → Server:** `agent.subscribe`, `agent.unsubscribe`, `hil.respond`",
      "version": 4,
      "updatedAt": "2026-03-01T17:59:55.413Z"
    },
    "non_functional_requirements": {
      "content": "| Category        | Requirement                                                                                                 |\n| --------------- | ----------------------------------------------------------------------------------------------------------- |\n| Performance     | Agent output streaming < 500ms latency; task status updates within 1 second                                |\n| Scalability     | Up to 500 tasks; single Coder/Reviewer in v1                                                                |\n| Reliability     | Agent failures must not corrupt state; transactional, recoverable                                           |\n| Security        | Sandboxed code execution; filesystem isolation                                                             |\n| Usability       | First-time users reach Execute within 30 minutes without docs                                               |\n| Theme Support   | Light/dark/system; persists; no flash on load                                                             |\n| Data Integrity  | Full audit trail; no data loss on agent crash                                                              |\n| Testing         | 80% coverage; all layers automated; real-time results                                                      |\n| Offline Support | All core features work without internet                                                                     |",
      "version": 1,
      "updatedAt": "2026-02-25T00:03:38.391Z"
    },
    "open_questions": {
      "content": "All previously identified questions have been resolved and documented in the Resolved Decisions section of the full PRD. No open questions at this time.",
      "version": 1,
      "updatedAt": "2026-02-25T00:03:38.391Z"
    }
  },
  "changeLog": [
    {
      "section": "executive_summary",
      "version": 1,
      "source": "sketch",
      "timestamp": "2026-02-25T00:03:38.391Z",
      "diff": "[Initial content added]"
    },
    {
      "section": "problem_statement",
      "version": 1,
      "source": "sketch",
      "timestamp": "2026-02-25T00:03:38.391Z",
      "diff": "[Initial content added]"
    },
    {
      "section": "user_personas",
      "version": 1,
      "source": "sketch",
      "timestamp": "2026-02-25T00:03:38.391Z",
      "diff": "[Initial content added]"
    },
    {
      "section": "goals_and_metrics",
      "version": 1,
      "source": "sketch",
      "timestamp": "2026-02-25T00:03:38.391Z",
      "diff": "[Initial content added]"
    },
    {
      "section": "feature_list",
      "version": 1,
      "source": "sketch",
      "timestamp": "2026-02-25T00:03:38.391Z",
      "diff": "[Initial content added]"
    },
    {
      "section": "technical_architecture",
      "version": 1,
      "source": "sketch",
      "timestamp": "2026-02-25T00:03:38.391Z",
      "diff": "[Initial content added]"
    },
    {
      "section": "data_model",
      "version": 1,
      "source": "sketch",
      "timestamp": "2026-02-25T00:03:38.391Z",
      "diff": "[Initial content added]"
    },
    {
      "section": "api_contracts",
      "version": 1,
      "source": "sketch",
      "timestamp": "2026-02-25T00:03:38.391Z",
      "diff": "[Initial content added]"
    },
    {
      "section": "non_functional_requirements",
      "version": 1,
      "source": "sketch",
      "timestamp": "2026-02-25T00:03:38.391Z",
      "diff": "[Initial content added]"
    },
    {
      "section": "open_questions",
      "version": 1,
      "source": "sketch",
      "timestamp": "2026-02-25T00:03:38.391Z",
      "diff": "[Initial content added]"
    },
    {
      "section": "feature_list",
      "version": 2,
      "source": "plan",
      "timestamp": "2026-02-25T05:10:52.879Z",
      "diff": "[+1 lines, +217 chars]"
    },
    {
      "section": "technical_architecture",
      "version": 2,
      "source": "plan",
      "timestamp": "2026-02-25T05:10:52.879Z",
      "diff": "[+0 lines, +120 chars]"
    },
    {
      "section": "data_model",
      "version": 2,
      "source": "plan",
      "timestamp": "2026-02-25T05:10:52.879Z",
      "diff": "[+1 lines, +135 chars]"
    },
    {
      "section": "feature_list",
      "version": 3,
      "source": "eval",
      "timestamp": "2026-02-25T22:47:28.376Z",
      "diff": "[-41 lines, -1376 chars]"
    },
    {
      "section": "data_model",
      "version": 3,
      "source": "plan",
      "timestamp": "2026-02-25T23:47:10.307Z",
      "diff": "[+0 lines, +157 chars]"
    },
    {
      "section": "technical_architecture",
      "version": 3,
      "source": "plan",
      "timestamp": "2026-02-25T23:47:10.307Z",
      "diff": "[+0 lines, +89 chars]"
    },
    {
      "section": "feature_list",
      "version": 4,
      "source": "plan",
      "timestamp": "2026-02-25T23:47:10.307Z",
      "diff": "[+4 lines, +323 chars]"
    },
    {
      "section": "api_contracts",
      "version": 2,
      "source": "plan",
      "timestamp": "2026-02-25T23:47:10.307Z",
      "diff": "[+0 lines, +134 chars]"
    },
    {
      "section": "data_model",
      "version": 4,
      "source": "eval",
      "timestamp": "2026-02-26T00:13:16.368Z",
      "diff": "[+64 lines, +5891 chars]"
    },
    {
      "section": "feature_list",
      "version": 5,
      "source": "plan",
      "timestamp": "2026-02-27T21:24:16.792Z",
      "diff": "[No changes]"
    },
    {
      "section": "api_contracts",
      "version": 3,
      "source": "plan",
      "timestamp": "2026-02-27T21:24:16.792Z",
      "diff": "[No changes]"
    },
    {
      "section": "data_model",
      "version": 5,
      "source": "plan",
      "timestamp": "2026-02-27T21:24:16.792Z",
      "diff": "[No changes]"
    },
    {
      "section": "data_model",
      "version": 6,
      "source": "plan",
      "timestamp": "2026-03-01T17:59:55.413Z",
      "diff": "[+6 lines, +723 chars]"
    },
    {
      "section": "api_contracts",
      "version": 4,
      "source": "plan",
      "timestamp": "2026-03-01T17:59:55.413Z",
      "diff": "[+4 lines, +498 chars]"
    },
    {
      "section": "feature_list",
      "version": 6,
      "source": "plan",
      "timestamp": "2026-03-01T17:59:55.413Z",
      "diff": "[+2 lines, +612 chars]"
    }
  ]
}